# -*- coding: utf-8 -*-
"""CircSimulationInPyCuda

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XE7cRDdnqgt9gOcCr57-gor1trIemjww
"""

import pycuda.driver as cuda
import pycuda.autoinit
from pycuda.compiler import SourceModule
import numpy as np
import matplotlib.pyplot as plt
import PIL
import csv

size = 70 #Square with 70x70
mask = np.array(PIL.Image.open('./Resources/Mask5_70_70.png'),dtype=np.bool_)[:,:,0]
mask = np.array(mask)

mask_gpu = cuda.mem_alloc(mask.nbytes)
cuda.memcpy_htod(mask_gpu, mask)

def sample_spherical(ndim=3):
    vec = np.random.randn(ndim)
    vec /= np.linalg.norm(vec)
    return vec


randomVec = np.ones([1000000,3])
for i in range(1000000):
    randomVec[i] = sample_spherical()*np.random.normal()
randomVec = randomVec.astype(np.float32)

rndVec_gpu = cuda.mem_alloc(randomVec.nbytes)
cuda.memcpy_htod(rndVec_gpu, randomVec)

seed = np.uint32(np.random.randint(0,4294967295))

seed_gpu = cuda.mem_alloc(seed.nbytes)
cuda.memcpy_htod(seed_gpu, seed)

singleSkyr = np.load("./Resources/SingleSkyrm.npy")
initState = np.load("./Resources/initPosCir.npy")

def SetSkyr(spins,PixelPosX,PixelPosY):
  for i in range(singleSkyr.shape[0]):
    for j in range(singleSkyr.shape[1]):
      idx = PixelPosX-int(singleSkyr.shape[0]/2)+i
      idy = PixelPosY-int(singleSkyr.shape[1]/2)+j
      dist = np.sqrt((i-singleSkyr.shape[0]*0.5)**2+(j-singleSkyr.shape[1]*0.5)**2)/singleSkyr.shape[0]*2
      spins[idx][idy] = singleSkyr[i][j]+(spins[idx][idy]-singleSkyr[i][j])*(1/(1+np.exp(-20*(dist-1))))
      spins[idx][idy] = spins[idx][idy]/np.sqrt(np.dot(spins[idx][idy],spins[idx][idy]))


def SetToInitial(SkrNr):
  rndPhase = np.random.rand()*2*np.pi
  rndRad = np.random.rand()*6+18
  spins = initState.copy().astype(np.float32)
  if SkrNr == 0:
    return spins
  elif SkrNr == 1:
    SetSkyr(spins,35,35)
    return spins
  elif SkrNr <= 4:
    for i in range(SkrNr):
      phi = i/float(SkrNr)*2*np.pi
      x,y = 35+rndRad*np.cos(phi+rndPhase), 35+rndRad*np.sin(phi+rndPhase)
      SetSkyr(spins,int(x),int(y))
    return spins
  else:
    for i in range(SkrNr-1):
      phi = i/float(SkrNr-1)*2*np.pi
      x,y = 35+rndRad*np.cos(phi+rndPhase), 35+rndRad*np.sin(phi+rndPhase)
      SetSkyr(spins,int(x),int(y))
    SetSkyr(spins,35,35)
    return spins

def GetTriArea (r_1, r_2, r_3) :
  N = np.dot (r_1, np.cross (r_2, r_3))
  D = 1.0 + np.dot (r_1, r_2) + np.dot (r_2, r_3) + np.dot (r_2, r_3)
  return 2 * np.arctan2 (N, D)
    

def CalQTopo(spins):
  sum = 0
  for i in range(size-1):
    for j in range(size-1):
      if mask[i][j] == False and mask[i+1][j] == False and mask[i][j+1] == False:
        sum += GetTriArea(spins[i][j],spins[i+1][j],spins[i][j+1])
        if not mask[i+1][j+1]:
          sum += GetTriArea(spins[i][j],spins[i+1][j],spins[i+1][j+1])

  return sum/(4*np.pi)


spins = SetToInitial(np.random.randint(1,9))
spins_gpu = cuda.mem_alloc(spins.nbytes)
cuda.memcpy_htod(spins_gpu, spins)
plt.imshow(spins[:,:,2])

avgTex = np.zeros([70,70],dtype=np.float32)
avgTex_gpu = cuda.mem_alloc(avgTex.nbytes)
cuda.memcpy_htod(avgTex_gpu, avgTex)

mu_s=1.037e-4#eV / T
J_0 = 5.72e-3
DM_0 = 1.52e-3
anisoStrength = 4e-4 #Anisotropy in Z
BStrength = 1.5 #B-Field in Z
gamma = 176.1 #rad/(ns * T) 
alpha = 0.05
dt = 0.000001
temperature = 0
k_B = 8.617333e-5; # eV / K

constString = "__constant__ float J_0 = "+str(J_0/mu_s)+";__constant__ float DM_0 = "+str(DM_0/mu_s)+";__constant__ float AnisoStrength = "+str(anisoStrength/mu_s)+";__constant__ float Gamma = "+str(gamma)+";__constant__ float alpha = "+str(alpha)+";__constant__ float dt = "+str(f"{dt:.9f}")+";__constant__ int size = "+str(size)+";"

D = np.float32(np.sqrt (alpha * k_B * temperature / (gamma * mu_s*dt) ))

D_gpu = cuda.mem_alloc(D.nbytes)
cuda.memcpy_htod(D_gpu, D)

def CalculateD(temperature):
  D = np.float32(np.sqrt (alpha * k_B * temperature / (gamma * mu_s*dt) ))
  cuda.memcpy_htod(D_gpu, D)

mod = SourceModule("""
  __device__ float3 operator+(const float3 &a, const float3 &b) {
    return make_float3(a.x+b.x, a.y+b.y, a.z+b.z);
  } 

  __device__ float3 operator*(const float &a, const float3 &b) {
    return make_float3(a*b.x, a*b.y, a*b.z);
  }

  __device__ uint wang_hash(uint seed)
  {
      seed = (seed ^ 61) ^ (seed >> 16);
      seed *= 9;
      seed = seed ^ (seed >> 4);
      seed *= 0x27d4eb2d;
      seed = seed ^ (seed >> 15);
      return seed;
  }

  __device__ float dot(const float3 &a, const float3 &b) {
    return a.x*b.x+a.y*b.y+a.z*b.z;
  }

  __device__ float3 normalize(const float3 &a) {
    return rsqrt(dot(a,a))*a;
  }

  __device__ float3 cross(const float3 &a, const float3 &b)
  {
    return make_float3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);
  }

  __device__ int2 getNeigVec(const int &i)
  {
    switch(i) {
      case 0 :  return make_int2(1,0);
      case 1 : return make_int2(0,-1);
      case 2 : return make_int2(-1,0);
      case 3 : return make_int2(0,1);
    }
    return make_int2(1,0);
  }

  __device__ float3 getDMVec(const int &i)
  {
    switch(i) {
      case 0 :  return make_float3(0,1,0);
      case 1 : return make_float3(-1,0,0);
      case 2 : return make_float3(0,-1,0);
      case 3 : return make_float3(1,0,0);
    }
    return make_float3(0,1,0);
  }


  """
  +constString+
  """

  __global__ void SimStep(float3 *spin, bool *mask, float3 *rndVec, float &D, int &Seed)
  {
    int idx = blockIdx.x +threadIdx.x*blockDim.x;
    int idy = blockIdx.y +threadIdx.y*blockDim.y;
    if(idx >= size || idy >= size)
      return;
    int index = idx+idy*size;
    if(mask[index]){
      spin[index] = make_float3(0,0,0);
      return;
    }

    float3 B_eff = make_float3(0,0,-1)+2*AnisoStrength * dot(make_float3(0,0,1),spin[index])*make_float3(0,0,1);
    float3 H = D * rndVec[wang_hash((index*Seed))%1000000];
    for(int i = 0; i < 4; i++){
      int2 neigVec = getNeigVec(i);
      if(!mask[(idx+neigVec.x)+(idy+neigVec.y)*size] && idx+neigVec.x >= 0 && idy+neigVec.y >= 0 && idx+neigVec.x < size && idy+neigVec.y < size ){
        B_eff = B_eff + J_0 * spin[(idx+neigVec.x)+(idy+neigVec.y)*size];
        B_eff = B_eff + cross(DM_0 * getDMVec(i), spin[(idx+neigVec.x)+(idy+neigVec.y)*size]);
      }
    }
    spin[index] = normalize(spin[index] + (-1.0)*Gamma/(1.+alpha*alpha)*dt*cross(spin[index], (B_eff+H) + cross(alpha* spin[index],(B_eff+H))));
  }

  __global__ void AvgStep(float3 *spin, float *avgTex){
    int idx = blockIdx.x +threadIdx.x*blockDim.x;
    int idy = blockIdx.y +threadIdx.y*blockDim.y;
    if(idx >= size || idy >= size)
      return;
    int index = idx+idy*size;
    avgTex[index] = spin[index].z + avgTex[index];
  }
  """)
simStep = mod.get_function("SimStep")
avgStep = mod.get_function("AvgStep")

import time as tm
def simulateNSteps(N):
  for i in range(N):
      simStep(spins_gpu, mask_gpu, rndVec_gpu, D_gpu, seed_gpu, block=(9,9,1), grid=(9,9,1))
      seed = np.int32(np.random.randint(0,4294967295))
      cuda.memcpy_htod(seed_gpu, seed)

simTemp = 15

def simulate():
  spins = SetToInitial(np.random.randint(1,9))
  cuda.memcpy_htod(spins_gpu, spins)

  avgTex = np.zeros([70,70],dtype=np.float32)
  cuda.memcpy_htod(avgTex_gpu, avgTex)

  CalculateD(0)

  simulateNSteps(10000)

  spins_evolved = np.empty_like(spins)
  cuda.memcpy_dtoh(spins_evolved, spins_gpu)
  QTopoStart = CalQTopo(spins_evolved)
  
  CalculateD(simTemp)

  time = 0
  count = 0
  maxTime = 20
  SimStepsPerAvgRun = int(maxTime/dt/1000)

  while True:

    simulateNSteps(SimStepsPerAvgRun)

    time += SimStepsPerAvgRun*dt
    count +=1
    avgStep(spins_gpu,avgTex_gpu, block=(9,9,1), grid=(9,9,1))

    if(time >= maxTime):
      break

  CalculateD(0)

  simulateNSteps(10000)

  spins_evolved = np.empty_like(spins)
  cuda.memcpy_dtoh(spins_evolved, spins_gpu)
  QTopoEnd = CalQTopo(spins_evolved)

  avgImg = np.empty_like(avgTex)
  cuda.memcpy_dtoh(avgImg, avgTex_gpu)

  return avgImg/count, QTopoStart, QTopoEnd, count, SimStepsPerAvgRun




def appendData(filePath,avgImg,TopoChargeStart,TopoChargeEnd,NumberOfAvgRuns,SimStepsPerAvgRun):
  with open(filePath, mode='a') as csv_file:
      fieldnames = ['emp_name', 'dept', 'birth_month']
      writer = csv.writer(csv_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)

      rest = np.array([J_0,DM_0,anisoStrength,TopoChargeEnd,TopoChargeStart,NumberOfAvgRuns,SimStepsPerAvgRun,size,size,1,dt,0,gamma,alpha,mu_s,simTemp,0,0,1.5],dtype=np.float32)
      writer.writerow(np.concatenate((avgImg.flatten(),rest)))
      
for i in range(50):
  #print(i)
  avgImg,TopoChargeStart,TopoChargeEnd,NumberOfAvgRuns,SimStepsPerAvgRun = simulate()
  appendData("./Results/circDataOUTPUTNUM.csv",avgImg,TopoChargeStart,TopoChargeEnd,NumberOfAvgRuns,SimStepsPerAvgRun)


